<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>小精靈 Pac-Man</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a2e;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Segoe UI', sans-serif;
    color: #e0e0e0;
    user-select: none;
  }
  .game-container {
    display: flex;
    gap: 24px;
    align-items: flex-start;
  }
  .side-panel {
    width: 160px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .panel-box {
    background: #16213e;
    border: 2px solid #0f3460;
    border-radius: 8px;
    padding: 12px;
  }
  .panel-box h3 {
    text-align: center;
    margin-bottom: 8px;
    color: #e94560;
    font-size: 14px;
    letter-spacing: 2px;
  }
  .stat-row {
    display: flex;
    justify-content: space-between;
    padding: 4px 0;
    font-size: 14px;
  }
  .stat-value {
    color: #53d8fb;
    font-weight: bold;
  }
  .lives-display {
    display: flex;
    justify-content: center;
    gap: 8px;
    padding: 8px 0;
  }
  .life-icon {
    width: 20px;
    height: 20px;
    background: #ffdd00;
    border-radius: 50%;
    position: relative;
    overflow: hidden;
  }
  .life-icon::after {
    content: '';
    position: absolute;
    top: 0; right: 0;
    width: 0; height: 0;
    border-top: 10px solid #16213e;
    border-bottom: 10px solid #16213e;
    border-left: 10px solid transparent;
  }
  canvas#game-canvas {
    border: 3px solid #0f3460;
    border-radius: 4px;
    box-shadow: 0 0 30px rgba(233, 69, 96, 0.3);
  }
  .controls {
    font-size: 12px;
    line-height: 1.8;
    color: #aaa;
  }
  .controls kbd {
    background: #0f3460;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 11px;
    color: #53d8fb;
  }
  .overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0,0,0,0.75);
    border-radius: 4px;
    gap: 12px;
  }
  .overlay.hidden { display: none; }
  .overlay h2 { color: #e94560; font-size: 28px; }
  .overlay p { color: #ccc; font-size: 14px; }
  .board-wrapper { position: relative; }
  .btn {
    background: #e94560;
    color: #fff;
    border: none;
    padding: 10px 28px;
    font-size: 16px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    letter-spacing: 1px;
  }
  .btn:hover { background: #c73652; }
</style>
</head>
<body>

<div class="game-container">
  <!-- Left Panel -->
  <div class="side-panel">
    <div class="panel-box">
      <h3>生命</h3>
      <div class="lives-display" id="lives-display"></div>
    </div>
    <div class="panel-box">
      <h3>分數</h3>
      <div class="stat-row"><span>分數</span><span class="stat-value" id="score">0</span></div>
      <div class="stat-row"><span>最高分</span><span class="stat-value" id="highscore">0</span></div>
      <div class="stat-row"><span>關卡</span><span class="stat-value" id="level">1</span></div>
    </div>
    <div class="panel-box controls">
      <h3>操作</h3>
      <kbd>←</kbd> <kbd>→</kbd> <kbd>↑</kbd> <kbd>↓</kbd> 移動<br>
      <kbd>P</kbd> 暫停
    </div>
    <div class="panel-box controls">
      <h3>說明</h3>
      <span style="color:#ffdd00;">●</span> 小精靈<br>
      <span style="color:#fff;">·</span> 豆子 10分<br>
      <span style="color:#fff;">●</span> 大力丸 50分<br>
      <span style="color:#53d8fb;">幽靈變藍</span> 可吃
    </div>
    <div class="panel-box" style="text-align:center;">
      <a href="index.html" style="color:#53d8fb; text-decoration:none; font-size:13px; letter-spacing:1px;">← 返回遊戲中心</a>
    </div>
  </div>

  <!-- Game Board -->
  <div class="board-wrapper">
    <canvas id="game-canvas"></canvas>
    <div class="overlay" id="start-overlay">
      <h2>小精靈 PAC-MAN</h2>
      <p>經典街機遊戲</p>
      <button class="btn" id="start-btn">開始遊戲</button>
    </div>
    <div class="overlay hidden" id="pause-overlay">
      <h2>暫停中</h2>
      <p>按 <kbd>P</kbd> 繼續</p>
    </div>
    <div class="overlay hidden" id="gameover-overlay">
      <h2>遊戲結束</h2>
      <p>最終分數: <span id="final-score">0</span></p>
      <button class="btn" id="restart-btn">再玩一次</button>
    </div>
    <div class="overlay hidden" id="win-overlay">
      <h2>過關！</h2>
      <p>分數: <span id="win-score">0</span></p>
      <button class="btn" id="next-btn">下一關</button>
    </div>
  </div>
</div>

<script>
// --- MAP ---
// 0=empty, 1=wall, 2=dot, 3=power pellet, 4=ghost house
const MAP_TEMPLATE = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
  [1,3,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,1,1,3,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,2,1,2,1,1,1,1,1,1,1,2,1,2,1,1,2,1],
  [1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1],
  [1,1,1,1,2,1,1,1,0,1,1,1,0,1,1,1,2,1,1,1,1],
  [0,0,0,1,2,1,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0],
  [1,1,1,1,2,1,0,1,1,4,4,4,1,1,0,1,2,1,1,1,1],
  [0,0,0,0,2,0,0,1,4,4,4,4,4,1,0,0,2,0,0,0,0],
  [1,1,1,1,2,1,0,1,1,1,1,1,1,1,0,1,2,1,1,1,1],
  [0,0,0,1,2,1,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0],
  [1,1,1,1,2,1,0,1,1,1,1,1,1,1,0,1,2,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,1,1,2,1],
  [1,3,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,1,2,3,1],
  [1,1,2,1,2,1,2,1,1,1,1,1,1,1,2,1,2,1,2,1,1],
  [1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1],
  [1,2,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

const COLS = MAP_TEMPLATE[0].length;
const ROWS = MAP_TEMPLATE.length;
const TILE = 28;
const canvas = document.getElementById('game-canvas');
canvas.width = COLS * TILE;
canvas.height = ROWS * TILE;
const ctx = canvas.getContext('2d');

const WALL_COLOR = '#0f3460';
const DOT_COLOR = '#e0e0e0';
const BG_COLOR = '#0a0a1a';
const PACMAN_COLOR = '#ffdd00';
const GHOST_COLORS = ['#ff0000', '#ffb8ff', '#00ffff', '#ffb852']; // red, pink, cyan, orange
const FRIGHTENED_COLOR = '#2233ff';

let map, score, lives, level, highScore = 0;
let pacman, ghosts;
let gameState = 'idle'; // idle, playing, paused, over, win
let animFrame, lastTime = 0, accumulator = 0;
let frightenedTimer = 0;
const STEP = 1000 / 60;
let mouthAngle = 0, mouthDir = 1;
let dotCount = 0, totalDots = 0;
let ghostEatCombo = 0;

function cloneMap() {
  return MAP_TEMPLATE.map(r => [...r]);
}

function countDots(m) {
  let c = 0;
  for (const row of m) for (const v of row) if (v === 2 || v === 3) c++;
  return c;
}

function createPacman() {
  return { x: 10, y: 15, dir: 0, nextDir: 0, moving: false, speed: 0.08 + level * 0.005 };
  // dir: 0=right,1=down,2=left,3=up
}

function createGhosts() {
  const home = [
    { x: 9, y: 9 },
    { x: 10, y: 9 },
    { x: 11, y: 9 },
    { x: 10, y: 8 },
  ];
  return home.map((pos, i) => ({
    x: pos.x, y: pos.y,
    dir: Math.floor(Math.random() * 4),
    color: GHOST_COLORS[i],
    frightened: false,
    eaten: false,
    speed: 0.04 + level * 0.004 + i * 0.003,
    moveTimer: 0,
    releaseTimer: i * 120,
    released: i === 3,
    index: i,
  }));
}

const DX = [1, 0, -1, 0];
const DY = [0, 1, 0, -1];

function isWalkable(tx, ty) {
  // wrap tunnel
  if (tx < 0 || tx >= COLS) return true;
  if (ty < 0 || ty >= ROWS) return false;
  const v = map[ty][tx];
  return v !== 1;
}

function isWalkableForGhost(tx, ty, ghost) {
  if (tx < 0 || tx >= COLS) return true;
  if (ty < 0 || ty >= ROWS) return false;
  const v = map[ty][tx];
  if (v === 1) return false;
  // ghost house: only enter if eaten, only exit if released
  if (v === 4 && !ghost.eaten && ghost.released) return true;
  return v !== 1;
}

function wrapX(x) {
  if (x < -0.5) return COLS - 0.5;
  if (x >= COLS + 0.5) return -0.5;
  return x;
}

function updatePacman() {
  const p = pacman;
  // try next direction
  const ntx = Math.round(p.x + DX[p.nextDir] * 0.5);
  const nty = Math.round(p.y + DY[p.nextDir] * 0.5);
  if (isWalkable(ntx, nty) && map[nty] && map[nty][ntx] !== 4) {
    p.dir = p.nextDir;
    p.moving = true;
  }

  if (p.moving) {
    const nx = p.x + DX[p.dir] * p.speed;
    const ny = p.y + DY[p.dir] * p.speed;
    const checkX = Math.round(nx + DX[p.dir] * 0.45);
    const checkY = Math.round(ny + DY[p.dir] * 0.45);

    if (isWalkable(checkX, checkY) && (checkY < 0 || checkY >= ROWS || map[checkY]?.[checkX] !== 4)) {
      p.x = wrapX(nx);
      p.y = ny;
    } else {
      p.x = Math.round(p.x);
      p.y = Math.round(p.y);
      p.moving = false;
    }
  }

  // eat dots
  const tileX = Math.round(p.x);
  const tileY = Math.round(p.y);
  if (tileX >= 0 && tileX < COLS && tileY >= 0 && tileY < ROWS) {
    const cell = map[tileY][tileX];
    if (cell === 2) {
      map[tileY][tileX] = 0;
      score += 10;
      dotCount++;
    } else if (cell === 3) {
      map[tileY][tileX] = 0;
      score += 50;
      dotCount++;
      frightenedTimer = 360 - level * 30;
      if (frightenedTimer < 120) frightenedTimer = 120;
      ghostEatCombo = 0;
      for (const g of ghosts) {
        if (!g.eaten) g.frightened = true;
        // reverse direction
        g.dir = (g.dir + 2) % 4;
      }
    }
  }

  // check win
  if (dotCount >= totalDots) {
    gameState = 'win';
    cancelAnimationFrame(animFrame);
    document.getElementById('win-score').textContent = score;
    showOverlay('win');
  }

  // mouth animation
  mouthAngle += 0.08 * mouthDir;
  if (mouthAngle > 0.35) mouthDir = -1;
  if (mouthAngle < 0.02) mouthDir = 1;
}

function ghostTarget(ghost) {
  const p = pacman;
  switch (ghost.index) {
    case 0: // red - chase pacman directly
      return { x: Math.round(p.x), y: Math.round(p.y) };
    case 1: // pink - target 4 tiles ahead of pacman
      return { x: Math.round(p.x + DX[p.dir] * 4), y: Math.round(p.y + DY[p.dir] * 4) };
    case 2: // cyan - complex targeting
      return { x: Math.round(p.x + DX[p.dir] * 2), y: Math.round(p.y + DY[p.dir] * 2) };
    case 3: // orange - chase if far, scatter if close
      const dist = Math.abs(ghost.x - p.x) + Math.abs(ghost.y - p.y);
      if (dist > 8) return { x: Math.round(p.x), y: Math.round(p.y) };
      return { x: 0, y: ROWS };
    default:
      return { x: Math.round(p.x), y: Math.round(p.y) };
  }
}

function updateGhosts() {
  // frightened timer
  if (frightenedTimer > 0) {
    frightenedTimer--;
    if (frightenedTimer <= 0) {
      for (const g of ghosts) g.frightened = false;
    }
  }

  for (const ghost of ghosts) {
    // release timer
    if (!ghost.released) {
      ghost.releaseTimer--;
      if (ghost.releaseTimer <= 0) {
        ghost.released = true;
        ghost.x = 10;
        ghost.y = 8;
        ghost.dir = 3;
      }
      continue;
    }

    ghost.moveTimer += ghost.frightened ? ghost.speed * 0.5 : (ghost.eaten ? ghost.speed * 2 : ghost.speed);
    if (ghost.moveTimer < 1) continue;
    ghost.moveTimer = 0;

    // if eaten, go back to house
    if (ghost.eaten) {
      if (Math.abs(ghost.x - 10) < 0.5 && Math.abs(ghost.y - 9) < 0.5) {
        ghost.eaten = false;
        ghost.frightened = false;
        ghost.x = 10;
        ghost.y = 9;
      } else {
        // move toward house
        const target = { x: 10, y: 9 };
        chooseBestDir(ghost, target);
        moveGhost(ghost);
      }
      continue;
    }

    const atIntersection = isAtTile(ghost);
    if (atIntersection) {
      if (ghost.frightened) {
        // random direction
        const options = [];
        for (let d = 0; d < 4; d++) {
          if (d === (ghost.dir + 2) % 4) continue; // no reverse
          const ntx = Math.round(ghost.x) + DX[d];
          const nty = Math.round(ghost.y) + DY[d];
          if (isWalkable(ntx, nty)) options.push(d);
        }
        if (options.length > 0) ghost.dir = options[Math.floor(Math.random() * options.length)];
      } else {
        const target = ghostTarget(ghost);
        chooseBestDir(ghost, target);
      }
    }

    moveGhost(ghost);

    // check collision with pacman
    if (Math.abs(ghost.x - pacman.x) < 0.6 && Math.abs(ghost.y - pacman.y) < 0.6) {
      if (ghost.frightened && !ghost.eaten) {
        ghost.eaten = true;
        ghost.frightened = false;
        ghostEatCombo++;
        score += 200 * ghostEatCombo;
      } else if (!ghost.eaten) {
        pacmanDie();
        return;
      }
    }
  }
}

function isAtTile(ghost) {
  return Math.abs(ghost.x - Math.round(ghost.x)) < 0.1 && Math.abs(ghost.y - Math.round(ghost.y)) < 0.1;
}

function chooseBestDir(ghost, target) {
  let bestDist = Infinity;
  let bestDir = ghost.dir;
  for (let d = 0; d < 4; d++) {
    if (d === (ghost.dir + 2) % 4) continue; // no reverse
    const ntx = Math.round(ghost.x) + DX[d];
    const nty = Math.round(ghost.y) + DY[d];
    if (!isWalkable(ntx, nty)) continue;
    const dist = (ntx - target.x) ** 2 + (nty - target.y) ** 2;
    if (dist < bestDist) {
      bestDist = dist;
      bestDir = d;
    }
  }
  ghost.dir = bestDir;
}

function moveGhost(ghost) {
  const nx = ghost.x + DX[ghost.dir];
  const ny = ghost.y + DY[ghost.dir];
  const checkX = Math.round(nx);
  const checkY = Math.round(ny);
  if (isWalkable(checkX, checkY)) {
    ghost.x = wrapX(nx);
    ghost.y = ny;
  } else {
    ghost.x = Math.round(ghost.x);
    ghost.y = Math.round(ghost.y);
    // pick new direction
    const options = [];
    for (let d = 0; d < 4; d++) {
      const tx2 = Math.round(ghost.x) + DX[d];
      const ty2 = Math.round(ghost.y) + DY[d];
      if (isWalkable(tx2, ty2)) options.push(d);
    }
    if (options.length > 0) ghost.dir = options[Math.floor(Math.random() * options.length)];
  }
}

function pacmanDie() {
  lives--;
  updateLives();
  if (lives <= 0) {
    gameState = 'over';
    cancelAnimationFrame(animFrame);
    if (score > highScore) highScore = score;
    document.getElementById('highscore').textContent = highScore;
    document.getElementById('final-score').textContent = score;
    showOverlay('gameover');
  } else {
    // reset positions
    pacman = createPacman();
    ghosts = createGhosts();
    frightenedTimer = 0;
  }
}

function updateLives() {
  const container = document.getElementById('lives-display');
  container.innerHTML = '';
  for (let i = 0; i < lives; i++) {
    const div = document.createElement('div');
    div.className = 'life-icon';
    container.appendChild(div);
  }
}

function updateStats() {
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  document.getElementById('highscore').textContent = highScore;
}

// --- DRAW ---
function draw() {
  ctx.fillStyle = BG_COLOR;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // draw map
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const v = map[r][c];
      const cx = c * TILE + TILE / 2;
      const cy = r * TILE + TILE / 2;
      if (v === 1) {
        drawWall(c, r);
      } else if (v === 2) {
        ctx.fillStyle = DOT_COLOR;
        ctx.beginPath();
        ctx.arc(cx, cy, 2.5, 0, Math.PI * 2);
        ctx.fill();
      } else if (v === 3) {
        ctx.fillStyle = DOT_COLOR;
        ctx.beginPath();
        ctx.arc(cx, cy, 7, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // draw ghosts
  for (const ghost of ghosts) {
    if (!ghost.released && !ghost.eaten) continue;
    drawGhost(ghost);
  }

  // draw pacman
  drawPacman();

  updateStats();
}

function drawWall(c, r) {
  const x = c * TILE;
  const y = r * TILE;
  ctx.fillStyle = WALL_COLOR;
  ctx.fillRect(x, y, TILE, TILE);

  // rounded look: check neighbors
  ctx.fillStyle = '#1a2a5e';
  const pad = 3;
  ctx.fillRect(x + pad, y + pad, TILE - pad * 2, TILE - pad * 2);

  // border glow
  ctx.strokeStyle = '#2a4a8e';
  ctx.lineWidth = 1;
  // draw edges only where adjacent to non-wall
  if (r > 0 && map[r-1][c] !== 1) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + TILE, y); ctx.stroke(); }
  if (r < ROWS-1 && map[r+1][c] !== 1) { ctx.beginPath(); ctx.moveTo(x, y + TILE); ctx.lineTo(x + TILE, y + TILE); ctx.stroke(); }
  if (c > 0 && map[r][c-1] !== 1) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + TILE); ctx.stroke(); }
  if (c < COLS-1 && map[r][c+1] !== 1) { ctx.beginPath(); ctx.moveTo(x + TILE, y); ctx.lineTo(x + TILE, y + TILE); ctx.stroke(); }
}

function drawPacman() {
  const p = pacman;
  const cx = p.x * TILE + TILE / 2;
  const cy = p.y * TILE + TILE / 2;
  const r = TILE / 2 - 2;
  const angle = [0, Math.PI / 2, Math.PI, -Math.PI / 2][p.dir];

  ctx.fillStyle = PACMAN_COLOR;
  ctx.beginPath();
  ctx.arc(cx, cy, r, angle + mouthAngle, angle + Math.PI * 2 - mouthAngle);
  ctx.lineTo(cx, cy);
  ctx.closePath();
  ctx.fill();

  // eye
  const eyeDist = 5;
  const eyeAngle = angle - Math.PI / 4;
  const ex = cx + Math.cos(eyeAngle) * eyeDist;
  const ey = cy + Math.sin(eyeAngle) * eyeDist;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(ex, ey, 2, 0, Math.PI * 2);
  ctx.fill();
}

function drawGhost(ghost) {
  const cx = ghost.x * TILE + TILE / 2;
  const cy = ghost.y * TILE + TILE / 2;
  const r = TILE / 2 - 2;

  if (ghost.eaten) {
    // just eyes
    drawGhostEyes(cx, cy, ghost.dir);
    return;
  }

  const color = ghost.frightened
    ? (frightenedTimer < 90 && Math.floor(frightenedTimer / 8) % 2 === 0 ? '#ffffff' : FRIGHTENED_COLOR)
    : ghost.color;

  // body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(cx, cy - 2, r, Math.PI, 0);
  ctx.lineTo(cx + r, cy + r - 2);
  // wavy bottom
  const waves = 3;
  const waveW = (r * 2) / waves;
  for (let i = 0; i < waves; i++) {
    const wx = cx + r - i * waveW;
    ctx.quadraticCurveTo(wx - waveW / 4, cy + r + 4, wx - waveW / 2, cy + r - 2);
    ctx.quadraticCurveTo(wx - waveW * 3 / 4, cy + r - 8, wx - waveW, cy + r - 2);
  }
  ctx.closePath();
  ctx.fill();

  // eyes
  if (ghost.frightened) {
    // frightened face
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(cx - 4, cy - 3, 3, 0, Math.PI * 2);
    ctx.arc(cx + 4, cy - 3, 3, 0, Math.PI * 2);
    ctx.fill();
    // wavy mouth
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(cx - 6, cy + 4);
    for (let i = 0; i < 4; i++) {
      ctx.lineTo(cx - 6 + i * 3 + 1.5, cy + (i % 2 === 0 ? 6 : 2));
    }
    ctx.stroke();
  } else {
    drawGhostEyes(cx, cy, ghost.dir);
  }
}

function drawGhostEyes(cx, cy, dir) {
  const offX = DX[dir] * 2.5;
  const offY = DY[dir] * 2.5;
  // whites
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.ellipse(cx - 5, cy - 3, 4, 5, 0, 0, Math.PI * 2);
  ctx.ellipse(cx + 5, cy - 3, 4, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  // pupils
  ctx.fillStyle = '#00f';
  ctx.beginPath();
  ctx.arc(cx - 5 + offX, cy - 3 + offY, 2, 0, Math.PI * 2);
  ctx.arc(cx + 5 + offX, cy - 3 + offY, 2, 0, Math.PI * 2);
  ctx.fill();
}

// --- GAME LOOP ---
function gameLoop(time) {
  if (gameState !== 'playing') return;
  const delta = time - lastTime;
  lastTime = time;
  accumulator += delta;
  while (accumulator >= STEP) {
    updatePacman();
    updateGhosts();
    accumulator -= STEP;
    if (gameState !== 'playing') return;
  }
  draw();
  animFrame = requestAnimationFrame(gameLoop);
}

function startGame() {
  level = 1;
  score = 0;
  lives = 3;
  initLevel();
  gameState = 'playing';
  showOverlay(null);
  lastTime = performance.now();
  accumulator = 0;
  animFrame = requestAnimationFrame(gameLoop);
}

function initLevel() {
  map = cloneMap();
  totalDots = countDots(map);
  dotCount = 0;
  pacman = createPacman();
  ghosts = createGhosts();
  frightenedTimer = 0;
  ghostEatCombo = 0;
  mouthAngle = 0.1;
  mouthDir = 1;
  updateLives();
  updateStats();
  draw();
}

function nextLevel() {
  level++;
  initLevel();
  gameState = 'playing';
  showOverlay(null);
  lastTime = performance.now();
  accumulator = 0;
  animFrame = requestAnimationFrame(gameLoop);
}

function togglePause() {
  if (gameState === 'playing') {
    gameState = 'paused';
    cancelAnimationFrame(animFrame);
    showOverlay('pause');
  } else if (gameState === 'paused') {
    gameState = 'playing';
    showOverlay(null);
    lastTime = performance.now();
    accumulator = 0;
    animFrame = requestAnimationFrame(gameLoop);
  }
}

function showOverlay(name) {
  document.getElementById('start-overlay').classList.toggle('hidden', name !== 'start');
  document.getElementById('pause-overlay').classList.toggle('hidden', name !== 'pause');
  document.getElementById('gameover-overlay').classList.toggle('hidden', name !== 'gameover');
  document.getElementById('win-overlay').classList.toggle('hidden', name !== 'win');
}

// --- INPUT ---
document.addEventListener('keydown', e => {
  if (gameState === 'playing') {
    switch (e.key) {
      case 'ArrowLeft':  pacman.nextDir = 2; break;
      case 'ArrowRight': pacman.nextDir = 0; break;
      case 'ArrowUp':    pacman.nextDir = 3; break;
      case 'ArrowDown':  pacman.nextDir = 1; break;
      case 'p': case 'P': togglePause(); break;
      default: return;
    }
    e.preventDefault();
  } else if (gameState === 'paused' && (e.key === 'p' || e.key === 'P')) {
    togglePause();
  }
});

// Buttons
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', startGame);
document.getElementById('next-btn').addEventListener('click', nextLevel);

// Init
showOverlay('start');
map = cloneMap();
draw();
updateLives();
</script>
</body>
</html>
